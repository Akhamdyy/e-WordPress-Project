import "@preact/signals";
import {
    useMemo as e
} from "preact/hooks";
import {
    Signal as t,
    signal as r,
    computed as n
} from "@preact/signals-core";
var a = new WeakMap,
    o = new WeakMap,
    s = new WeakMap,
    u = new WeakSet,
    c = new WeakMap,
    i = /^\$/,
    f = Object.getOwnPropertyDescriptor,
    l = !1,
    g = function(e) {
        if (!R(e)) throw new Error("This object can't be observed.");
        return o.has(e) || o.set(e, h(e, w)), o.get(e)
    },
    p = function(e, t) {
        l = !0;
        var r = e[t];
        try {
            l = !1
        } catch (e) {}
        return r
    },
    h = function(e, t) {
        var r = new Proxy(e, t);
        return u.add(r), r
    },
    y = function() {
        throw new Error("Don't mutate the signals directly.")
    },
    v = function(e) {
        return function(t, u, c) {
            var g;
            if (l) return Reflect.get(t, u, c);
            var p = e || "$" === u[0];
            if (!e && p && Array.isArray(t)) {
                if ("$" === u) return s.has(t) || s.set(t, h(t, m)), s.get(t);
                p = "$length" === u
            }
            a.has(c) || a.set(c, new Map);
            var y = a.get(c),
                v = p ? u.replace(i, "") : u;
            if (y.has(v) || "function" != typeof(null == (g = f(t, v)) ? void 0 : g.get)) {
                var d = Reflect.get(t, v, c);
                if (p && "function" == typeof d) return;
                if ("symbol" == typeof v && b.has(v)) return d;
                y.has(v) || (R(d) && (o.has(d) || o.set(d, h(d, w)), d = o.get(d)), y.set(v, r(d)))
            } else y.set(v, n(function() {
                return Reflect.get(t, v, c)
            }));
            return p ? y.get(v) : y.get(v).value
        }
    },
    w = {
        get: v(!1),
        set: function(e, n, s, u) {
            var l;
            if ("function" == typeof(null == (l = f(e, n)) ? void 0 : l.set)) return Reflect.set(e, n, s, u);
            a.has(u) || a.set(u, new Map);
            var g = a.get(u);
            if ("$" === n[0]) {
                s instanceof t || y();
                var p = n.replace(i, "");
                return g.set(p, s), Reflect.set(e, p, s.peek(), u)
            }
            var v = s;
            R(s) && (o.has(s) || o.set(s, h(s, w)), v = o.get(s));
            var m = !(n in e),
                b = Reflect.set(e, n, s, u);
            return g.has(n) ? g.get(n).value = v : g.set(n, r(v)), m && c.has(e) && c.get(e).value++, Array.isArray(e) && g.has("length") && (g.get("length").value = e.length), b
        },
        deleteProperty: function(e, t) {
            "$" === t[0] && y();
            var r = a.get(o.get(e)),
                n = Reflect.deleteProperty(e, t);
            return r && r.has(t) && (r.get(t).value = void 0), c.has(e) && c.get(e).value++, n
        },
        ownKeys: function(e) {
            return c.has(e) || c.set(e, r(0)), c._ = c.get(e).value, Reflect.ownKeys(e)
        }
    },
    m = {
        get: v(!0),
        set: y,
        deleteProperty: y
    },
    b = new Set(Object.getOwnPropertyNames(Symbol).map(function(e) {
        return Symbol[e]
    }).filter(function(e) {
        return "symbol" == typeof e
    })),
    d = new Set([Object, Array]),
    R = function(e) {
        return "object" == typeof e && null !== e && (!("function" == typeof e.constructor && e.constructor.name in globalThis && globalThis[e.constructor.name] === e.constructor) || d.has(e.constructor)) && !u.has(e)
    },
    k = function(t) {
        return e(function() {
            return g(t)
        }, [])
    };
export {
    g as deepSignal, p as peek, k as useDeepSignal
}; //# sourceMappingURL=deepsignal.module.js.map